// must import openpgp module before using these functions

/**
 * generates PGP public and private keys
 * @param: userId the unique user identifier
 * @param: pass the user chosen passphrase
 * @return: a promise of the openpgp.key object
 */
function generate_asym_keys(userId, pass) {
    options = {
        userIds: [{name: userId, email: ''}],
        numBits: 2048,
        passphrase: pass
    };

    return openpgp.generateKey(options);
}

/**
 * takes a message and encrypts it using PGP RSA
 * @param: plaintext the unencrypted message
 * @param: pubkey the key used to encrypt
 * @return: a promise of the encrypted message
 */
function encrypt_asym_message(plaintext, pubkey) {
    options = {
        data: Uint8Array.from(plaintext),
        publicKeys: openpgp.key.readArmored(pubkey).keys,
        armor: false
    };

    return openpgp.encrypt(options);
}

/**
 * decrypts an encrypted message using PGP RSA
 * @param: ciphertext the encrypted message
 * @param: privkey the private key to decrypt
 * @return: a promise fo the decrypted plaintext
 */
function decrypt_asym_message(ciphertext, privkey) {
    options = {
        message: openpgp.message.read(ciphertext),
        privateKey: openpgp.key.readArmored(privkey).keys[0],
        format: 'binary'
    };

    return openpgp.decrypt(options);
}

/**
 * generates a AES key
 *  key - 256 bits or 32 characters
 *  iv - 128 bits or 16 characters
 * @return: an array of [key, iv]
 */
function generate_sym_key() {
    var key = generate_random_bits(32);
    var iv = generate_random_bits(16);
    return [key, iv];
}

/**
 * Encrypts a message using a given key and iv
 * @param: plaintext the plaintext string to encrypt
 * @param: key the 32 byte key to encrypt with
 * @param: iv the 16 byte iv to encrypt with
 * @return: the encrypted string
 */
function encrypt_sym_message(plaintext, key, iv) {
    var textBytes = aesjs.util.convertStringToBytes(plaintext);
    var aesCbc = new aesjs.ModeOfOperation.cbc(key, iv);
    return aesjs.util.convertBytesToString(aesCbc.encrypt(textBytes));
}

/**
 * Decrypts a message using a given key and iv
 * @param: ciphertext the encrypted byte array to decrypt
 * @param: key the key to decrypt with
 * @param: iv the iv to decrypt with
 * @return: the decrypted string
 */
function decrypt_sym_message(ciphertext, key, iv) {
    var aesCbc = new aesjs.ModeOfOperation.cbc(key, iv);
    var decryptedBytes = aesCbc.decrypt(ciphertext);
    return aesjs.util.convertBytesToString(decryptedBytes);
}

/**
 * randomly generates a string of bits
 * @param: nBytes the number of bytes to generate
 * @return: a Uint8Array of nBytes length with randomly generated bytes
 */
function generate_random_bits(nBytes) {
    var i;
    var random_arr = new Uint8Array(nBytes);
    for (i = 0; i < nBytes; i++) {
       random_arr[i] = Math.floor(Math.random() * 256);
    }
}
