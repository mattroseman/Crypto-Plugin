// must import openpgp module before using these functions

/**
 * generates PGP public and private keys
 * @param: userId the unique user identifier
 * @param: pass the user chosen passphrase
 * @return: a promise of the openpgp.key object
 */
function generate_asym_keys(userId, pass) {
    options = {
        userIds: [{name: userId, email: ''}],
        numBits: 2048,
        passphrase: pass
    };

    return openpgp.generateKey(options);
}

/**
 * takes a message and encrypts it using PGP RSA
 * @param: plaintext the unencrypted message
 * @param: pubkey the key used to encrypt
 * @return: a promise of the encrypted message
 */
function encrypt_asym_message(plaintext, pubkey) {
    options = {
        data: Uint8Array.from(plaintext),
        publicKeys: openpgp.key.readArmored(pubkey).keys,
        armor: false
    };

    return openpgp.encrypt(options);
}

/**
 * decrypts an encrypted message using PGP RSA
 * @param: ciphertext the encrypted message
 * @param: privkey the private key to decrypt
 * @return: a promise fo the decrypted plaintext
 */
function decrypt_asym_message(ciphertext, privkey) {
    options = {
        message: openpgp.message.read(ciphertext),
        privateKey: privkey.key,
        format: 'binary'
    };

    return openpgp.decrypt(options);
}

/**
 * generates a AES key
 *  key - 128 bits or 32 characters
 * @return: a 128 bit key
 */
function generate_sym_key() {
    var key = generate_random_bits(16);
    return key;
}

/**
 * Encrypts a message using a given key
 * @param: plaintext the plaintext string to encrypt
 * @param: key the 16 byte key to encrypt with
 * @return: the encrypted string
 */
function encrypt_sym_message(plaintext, key) {
    /*var ciphertext = "";
    var encryptedBytes = null;
    var aesCbc = new aesjs.ModeOfOperation.cbc(key, iv);

    while (plaintext.length !== 0) {
        // first 16 characters of plaintext
        var Byte16SubString = plaintext.slice(0,16);
        // if there are x spaces to buffer then add x x's to the end of the string
        //Byte16SubString += (" " * (16 - Byte16SubString.length));
        var x;
        if ((x = 16 - Byte16SubString.length) > 0) {
            for (var i=0; i<x; i++) {
                Byte16SubString += x.toString(16);
            }
        }
        var textBytes = aesjs.util.convertStringToBytes(Byte16SubString);
        if (encryptedBytes !== null) {
            encryptedBytes += aesCbc.encrypt(textBytes);
        } else {
            encryptedBytes = aesCbc.encrypt(textBytes);
        }
        ciphertext +=  aesjs.util.convertBytesToString(encryptedBytes);

        plaintext = plaintext.slice(16, plaintext.length);
    }

    return ciphertext;*/
   var textBytes = aesjs.util.convertStringToBytes(plaintext);
   var aesCtr = new aesjs.ModeOfOperation.ctr(key, new aesjs.Counter(5));
   var encryptedBytes = aesCtr.encrypt(textBytes);

   return encryptedBytes;
}

/**
 * Decrypts a message using a given key
 * @param: ciphertext the encrypted byte array to decrypt
 * @param: key the key to decrypt with
 * @return: the decrypted string
 */
function decrypt_sym_message(ciphertext, key) {
    /*var aesCbc = new aesjs.ModeOfOperation.cbc(key, iv);
    var decryptedBytes = aesCbc.decrypt(ciphertext);
    return aesjs.util.convertBytesToString(decryptedBytes);*/
   var aesCtr = new aesjs.ModeOfOperation.ctr(key, new aesjs.Counter(5));
   var decryptedBytes = aesCtr.decrypt(ciphertext);
   var decryptedText = aesjs.util.convertBytesToString(decryptedBytes);
   return decryptedText;
}

/**
 * randomly generates a string of bits
 * @param: nBytes the number of bytes to generate
 * @return: a Uint8Array of nBytes length with randomly generated bytes
 */
function generate_random_bits(nBytes) {
    var i;
    var random_arr = new Uint8Array(nBytes);
    for (i = 0; i < nBytes; i++) {
       random_arr[i] = Math.floor(Math.random() * 256);
    }

    return random_arr;
}
